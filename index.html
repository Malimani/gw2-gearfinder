<!DOCTYPE html>
<html lang="en">
<head>
  <script defer data-domain="gw2gear.com" src="https://plausible.io/js/script.js"></script>
  <meta charset="UTF-8" />
  <link rel="icon" href="assets/favicon.png" type="image/png">
  <title>Good Ways 2 Gear</title>
  <style>
body {
    font-family: sans-serif;
    background: #f0f0f0;
    padding: 2rem;
    display: flex;
    justify-content: center;
  }

  .container {
    max-width: 700px;
    width: 100%;
  }

  header {
    display: flex;
    align-items: center;
    gap: 1rem;
    margin-bottom: 2rem;
    flex-wrap: wrap;
  }

  header img {
    height: 48px;
  }

  header h1 {
    flex: 1;
    min-width: 200px;
    max-width: 100%;
  }

  h2 {
    font-size: 1.2em;
    margin-top: 2rem;
    margin-bottom: 0.5rem;
    color: #333;
    border-bottom: 1px solid #ddd;
    padding-bottom: 0.25rem;
  }

  select {
    margin-bottom: 1rem;
    padding: 0.5rem;
    width: 100%;
    max-width: 700px;
  }

  .filters {
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
    align-items: center;
    margin-bottom: 1rem;
  }

  .filter-group {
    display: flex;
    border-radius: 0.75rem;
    overflow: hidden;
    box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    background: white;
  }

  .filter-button {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0.5rem 1rem;
    background: white;
    color: #333;
    font-weight: bold;
    cursor: pointer;
    border: none;
    border-right: 1px solid #ddd;
    box-sizing: border-box;
    transition: background 0.2s, color 0.2s;
    min-width: 6em;
  }

  .filter-button:last-child {
    border-right: none;
  }

  .filter-button.active {
    background: #0066cc;
    color: white;
  }

  .filter-rarity.ascended {
    box-shadow: inset 6px 0 0 #fb3e8d;
  }

  .filter-rarity.exotic {
    box-shadow: inset -6px 0 0 #ffa405;
  }

  .filter-weight.light::after {
    content: " 🪶";
    font-size: 1em;
  }

  .filter-weight.medium::after {
    content: " ⚖️";
    font-size: 1em;
  }

  .filter-weight.heavy::after {
    content: " 🪨";
    font-size: 1em;
  }

  .filter-group.filter-rarity .filter-button,
  .filter-group.filter-weight .filter-button {
    min-width: 6.5em;
  }

  .reset-button,
  #filters > button {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 2.5em;
    padding: 0.5rem 1.25rem;
    border-radius: 0.75rem;
    border: 1px solid #ccc;
    background: white;
    font-weight: bold;
    box-shadow: 0 2px 6px rgba(0,0,0,0.08);
    cursor: pointer;
  }

  .result {
    background: white;
    padding: 6px 1rem;
    margin-top: 0.75rem;
    border-radius: 0.75rem;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
    border-left: 6px solid transparent;
    transition: transform 0.2s, box-shadow 0.2s;
  }

    .result:first-child.exotic-tp {
  box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
}

  .result:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  }

  .result h3 {
    margin-bottom: 0.5rem;
    font-size: 1.2em;
    display: flex;
    align-items: center;
    flex-wrap: wrap;
    gap: 0.4rem;
  }

  .result h3 .icon {
    height: 1.5em;
    vertical-align: middle;
  }

  .result p {
    margin: 0.3rem 0;
  }

  .result a {
    color: #0066cc;
    text-decoration: none;
  }

  .result a:hover {
    text-decoration: underline;
  }

  .result img.icon {
    height: 1.5em;
    vertical-align: middle;
    margin-right: 0.5em;
  }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <img src="assets/logo.png" alt="Logo">
      <h1>
        Good Ways 2 Gear
        <small style="font-size: 0.6em; color: #666;">v1.2.0 &nbsp;|&nbsp; <span id="itemCounter">Loading items...</span>
      </small>
      </h1>

      <p style="margin-top: -1rem; font-size: 0.9em; color: #444;">
        Inspired by Tanetris's in depth guide: <a href="https://wiki.guildwars2.com/wiki/User:Tanetris/So_You_Want_To_Gear_a_Character" target="_blank" style="color: #0066cc; text-decoration: underline;"><em>So You Want To Gear a Character</em> <img src="assets/external-link.png" alt="external link" style='height: 0.9em; vertical-align: middle; margin-left: 0.3em;'></a>
      </p>
    </header>

    <select id="slotSelect">
      <option value="">-- Select Gear Slot --</option>
    </select>
    <select id="attributeSelect" style="display: none;"></select>
    <div class="filters" id="filters"></div>
    <div id="results"></div>

    <footer style="margin-top: 3rem; font-size: 0.8em; color: #777; text-align: center;">
      <p>
        <a href="Legal.html">Legal</a> |
        <a href="https://discord.gg/dtxTBbQdhP" target="_blank">Join our Discord</a> |
        Fan project – not affiliated with ArenaNet
      </p>
    </footer>
  </div>

  <script>
    const itemNameCache = {}; // ✅ Cache für Itemnamen
    const tpPriceCache = {};  // ✅ Cache für TP-Preise
    const slotSelect = document.getElementById("slotSelect");
    const attributeSelect = document.getElementById("attributeSelect");
    const filtersDiv = document.getElementById("filters");
    const resultsDiv = document.getElementById("results");

    let gearData = {};
    let attributeMap = {};
    let filters = { rarity: new Set(), weight_class: new Set() };
    let currentSlot = "";
    let currentAttrLabel = "";
    let slotTypeMap = {};
    let currencyIconMap = {};
    let craftComponentsMap = {};

    const apiQueue = [];
let tokens = 300;
const maxTokens = 300;

setInterval(() => {
  tokens = Math.min(tokens + 5, maxTokens);
  processQueue();
}, 1000);

function processQueue() {
  while (tokens > 0 && apiQueue.length > 0) {
    const { url, resolve, reject, retries } = apiQueue.shift();
    tokens--;

    fetch(url).then(res => {
      if (res.status === 429) {
        if (retries > 0) {
          // Warte 500ms und versuch es nochmal
          setTimeout(() => {
            apiQueue.push({ url, resolve, reject, retries: retries - 1 });
            processQueue();
          }, 500);
        } else {
          reject(new Error("Rate limit exceeded (429)"));
        }
      } else if (!res.ok) {
        reject(new Error(`HTTP Error: ${res.status}`));
      } else {
        res.json().then(resolve).catch(reject);
      }
    }).catch(reject);
  }
}

function rateLimitedFetch(url, maxRetries = 3) {
  return new Promise((resolve, reject) => {
    apiQueue.push({ url, resolve, reject, retries: maxRetries });
    processQueue();
  });
}
    
async function loadCraftComponents() {
  try {
    const compData = await fetch("craftcomp.json").then(r => r.json());
    for (const e of compData) {
      craftComponentsMap[e.id] = e.coin;
    }
  } catch (e) {
    console.warn("craftcomp.json missing", e);
  }
}

    async function loadSlotTypeMap() {
      try {
        const res = await fetch("slotTypeMap.json");
        slotTypeMap = await res.json();
      } catch (err) {
        console.error("Error loading slotTypeMap:", err);
      }
    }

    async function initialize() {
      try {
        const [attrRes, gearRes, slotMapRes, currencyRes] = await Promise.all([
          fetch("attributeMap.json"),
          fetch("gearData.json"),
          fetch("slotTypeMap.json"),
          fetch("currencyIconMap.json")
        ]);
        attributeMap = await attrRes.json();
        gearData = await gearRes.json();
        slotTypeMap = await slotMapRes.json();
        currencyIconMap = await currencyRes.json();  // ⬅️
        buildSlotDropdown();
        updateItemCounter();
      } catch (err) {
        console.error("Initialization error:", err);
      }
      await loadCraftComponents();
    }

    function updateItemCounter() {
      let itemCount = 0;
      for (const slot in gearData) {
        itemCount += gearData[slot].length;
        }
      const counterEl = document.getElementById("itemCounter");
      if (counterEl) {
        counterEl.textContent = `${itemCount} items`;
      }
    }

    function buildSlotDropdown() {
      const groupedSlots = {};
      for (const slot in gearData) {
        const group = slotTypeMap[slot] || "Other";
        if (!groupedSlots[group]) groupedSlots[group] = [];
        groupedSlots[group].push(slot);
      }
      for (const group of Object.keys(groupedSlots).sort()) {
        const optgroup = document.createElement("optgroup");
        optgroup.label = group;
        groupedSlots[group].sort().forEach(slot => {
          const option = document.createElement("option");
          option.value = slot;
          option.textContent = slot;
          optgroup.appendChild(option);
        });
        slotSelect.appendChild(optgroup);
      }
    }

    function buildAttributeDropdown(slot) {
      const seenLabels = new Set();
      const validOptions = [];
      const unknownOptions = [];
      attributeSelect.innerHTML = '<option value="">-- Select Attribute / Effect --</option>';
      const attrIds = new Set();
      gearData[slot].forEach(item => (item.attributes || []).forEach(id => attrIds.add(id.toString())));

      attrIds.forEach(id => {
        const label = attributeMap[id];
        const option = document.createElement("option");
        option.value = id;
        if (label) {
          if (!seenLabels.has(label)) {
            seenLabels.add(label);
            option.textContent = label;
            validOptions.push(option);
          }
        } else {
          option.textContent = `Attribute ${id}`;
          option.disabled = true;
          option.style.color = "#aaa";
          unknownOptions.push(option);
        }
      });

      [...validOptions.sort((a, b) => a.textContent.localeCompare(b.textContent)),
       ...unknownOptions.sort((a, b) => a.textContent.localeCompare(b.textContent))]
        .forEach(option => attributeSelect.appendChild(option));

      attributeSelect.style.display = 'block';
      for (let i = 0; i < attributeSelect.options.length; i++) {
      if (attributeSelect.options[i].textContent === currentAttrLabel) {
        attributeSelect.selectedIndex = i;
        break;
      }
    }
    }

    function renderFilters(items) {
      filtersDiv.innerHTML = "";
      const rarities = new Set();
      const weights = new Set();
      items.forEach(item => {
        if (item.rarity) rarities.add(item.rarity);
        if (item.weight_class) weights.add(item.weight_class);
      });

const createButton = (label, type) => {
  const btn = document.createElement("button");
  btn.textContent = label;
  btn.className = filters[type].has(label) ? "active" : "";

  btn.addEventListener("click", () => {
    const isExclusiveRarity = type === "rarity" && (label === "Ascended" || label === "Exotic");
    const isExclusiveWeight = type === "weight_class" && ["Light", "Medium", "Heavy"].includes(label);

    if (isExclusiveRarity || isExclusiveWeight) {
      // Exklusives Verhalten
      filters[type].clear();
      if (!btn.classList.contains("active")) {
        filters[type].add(label);
      }
    } else {
      // Fallback: normal togglen
      if (filters[type].has(label)) filters[type].delete(label);
      else filters[type].add(label);
    }

    const filteredItems = items.filter(entry =>
      (!filters.rarity.size || filters.rarity.has(entry.rarity)) &&
      (!filters.weight_class.size || (entry.weight_class && filters.weight_class.has(entry.weight_class)))
    );

    renderItems(filteredItems);
    renderFilters(items);
  });

  return btn;
};

// Rarity Group: Ascended + Exotic mit Farbbändern
const rarityGroup = document.createElement("div");
rarityGroup.className = "filter-group";

["Ascended", "Exotic"].forEach(r => {
  if (rarities.has(r)) {
    const btn = createButton(r, "rarity");
    btn.classList.add("filter-button", "filter-rarity");
    if (r === "Ascended") btn.classList.add("ascended");
    if (r === "Exotic") btn.classList.add("exotic");
    rarityGroup.appendChild(btn);
  }
});
filtersDiv.appendChild(rarityGroup);

// Weight Class Group: Light + Medium + Heavy mit Symbolen
const weightGroup = document.createElement("div");
weightGroup.className = "filter-group";

["Light", "Medium", "Heavy"].forEach(w => {
  if (weights.has(w)) {
    const btn = createButton(w, "weight_class");
    btn.classList.add("filter-button", "filter-weight", w.toLowerCase());
    weightGroup.appendChild(btn);
  }
});
filtersDiv.appendChild(weightGroup);


      if (rarities.size || weights.size) {
        const resetBtn = document.createElement("button");
        resetBtn.textContent = "Reset Filters";
        resetBtn.addEventListener("click", () => {
        filters.rarity.clear();
        filters.weight_class.clear();
        renderItems(items);
        renderFilters(items);
      });
        filtersDiv.appendChild(resetBtn);
      }
    }
   
function formatCurrency(input) {
  if (typeof input === "string") {
    const trimmed = input.trim();
    const match = trimmed.match(/^([0-9]+)([gsc])$/);
    if (match) {
      const amount = match[1];
      const unit = match[2];
      const iconMap = { g: "gold", s: "silver", c: "copper" };
      return `${amount}<img src='assets/${iconMap[unit]}.png' style='height:1em;'>`;
    }
    return trimmed.replaceAll("_", " ");
  }

  if (typeof input === "object" && input.currency && input.amount != null) {
    if (input.currency === "Coin") {
      const copper = input.amount;
      const g = Math.floor(copper / 10000);
      const s = Math.floor((copper % 10000) / 100);
      const c = copper % 100;

      let parts = [];
      if (g > 0) parts.push(`${g}<img src='assets/gold.png' style='height:1em;'>`);
      if (s > 0) parts.push(`${s}<img src='assets/silver.png' style='height:1em;'>`);
      if (c > 0 || (g === 0 && s === 0)) parts.push(`${c}<img src='assets/copper.png' style='height:1em;'>`);

      return parts.join(" ");
    }
    else if (currencyIconMap[input.currency]) {
  const icon = typeof currencyIconMap[input.currency] === "string"
    ? currencyIconMap[input.currency]
    : currencyIconMap[input.currency].icon;

  return `${input.amount.toLocaleString()} <img src='assets/${icon}' title='${input.currency.replaceAll("_", " ")}' style='height:1em; vertical-align:middle;'>`;
} else {
  return `${input.amount.toLocaleString()} ${input.currency.replaceAll("_", " ")}`;
}

    return `${input.amount.toLocaleString()} ${input.currency.replaceAll("_", " ")}`;
  }

  return String(input);
}

function createCostElement(entry) {
  const cost = document.createElement("p");

  if (!entry.cost || (Array.isArray(entry.cost) && entry.cost.length === 0)) {
    return document.createComment("No cost to display");
  }

  if (typeof entry.cost === "string" && entry.cost.startsWith("TP:")) {
    const tpId = entry.cost.slice(3);
    cost.innerHTML = tpPriceCache[tpId]?.html || `<strong>Cost:</strong> loading...`;
  } else if (typeof entry.cost === "string" && entry.cost.startsWith("craft:")) {
  const craftId = entry.cost.slice(6);
  cost.innerHTML = `<strong>Cost:</strong> calculating...`;

  getCraftingCost(craftId).then(copper => {
    if (copper < Number.MAX_SAFE_INTEGER) {
      cost.innerHTML = `<strong>Cost:</strong> ${formatPrice(copper)}`;
    } else {
      cost.innerHTML = `<strong>Cost:</strong> Unknown`;
    }
  });
}
else if (Array.isArray(entry.cost)) {
  const optionBlocks = [];

  for (const optionArr of entry.cost) {
    const formattedFragments = [];

    let isCraftOnly = false;
    for (const fragment of optionArr) {
      if (typeof fragment === "object" && fragment.currency?.startsWith("craft:")) {
        isCraftOnly = true;
        const craftId = fragment.currency.slice(6);
        formattedFragments.push(`<span data-crafting-cost="loading" data-id="${craftId}">calculating...</span>`);
      } else {
        formattedFragments.push(formatCurrency(fragment));
      }
    }

    optionBlocks.push(formattedFragments.join(" + "));
  }

  cost.innerHTML = `<strong>Cost:</strong> ${optionBlocks.join(" <span style='color:#666;'>/</span> ")}`;

  // nachträglich alle craft: Einträge berechnen und ersetzen
  const spanElements = cost.querySelectorAll("span[data-crafting-cost]");
  spanElements.forEach(async span => {
    const id = span.getAttribute("data-id");
    const copper = await getCraftingCost(id);
    if (copper < Number.MAX_SAFE_INTEGER) {
      span.innerHTML = formatPrice(copper);
    } else {
      span.innerHTML = "Unknown";
    }
  });
}
  else {
    cost.innerHTML = `<strong>Cost:</strong> ${entry.cost}`;
  }

  return cost;
}
  
async function renderItems(items = gearData[currentSlot]) {
  resultsDiv.innerHTML = "";
  document.querySelectorAll(".stat-swap-header, .stat-swap-entry").forEach(el => el.remove());
  if (!currentSlot || !gearData[currentSlot]) return;

  const attrIds = Object.entries(attributeMap)
    .filter(([, label]) => label.trim() === currentAttrLabel.trim())
    .map(([id]) => id);

  const filteredItems = items.filter(entry => {
    if (currentAttrLabel && (!entry.attributes || !entry.attributes.some(id => attrIds.includes(String(id))))) return false;
    if (filters.rarity.size && !filters.rarity.has(entry.rarity)) return false;
    if (filters.weight_class.size && (!entry.weight_class || !filters.weight_class.has(entry.weight_class))) return false;
    return true;
  });

  const tpItems = [];
  const otherExotics = [];
  const ascendedItems = [];
  const legendaryItems = [];

  for (const entry of filteredItems) {
    const isTP = typeof entry.cost === "string" && entry.cost.startsWith("TP:");
    if (entry.rarity === "Exotic" && isTP) {
      tpItems.push(entry);
    } else if (entry.rarity === "Exotic") {
      otherExotics.push(entry);
    } else if (entry.rarity === "Ascended") {
      ascendedItems.push(entry);
    } else if (entry.rarity === "Legendary") {
      legendaryItems.push(entry);
    }
  }

  const pricePromises = tpItems.map(entry => {
    const tpId = entry.cost.slice(3);
    if (tpPriceCache[tpId]) {
      entry._priceCopper = tpPriceCache[tpId].copperValue;
      return Promise.resolve();
    } else {
      return fetch(`https://api.guildwars2.com/v2/commerce/prices/${tpId}`)
        .then(res => res.json())
        .then(data => {
          const priceCopper = data.sells.unit_price;
          entry._priceCopper = priceCopper;
          tpPriceCache[tpId] = {
            html: `<strong>Cost:</strong> ${formatPrice(priceCopper)}`,
            copperValue: priceCopper
          };
        })
        .catch(() => {
          entry._priceCopper = Number.MAX_SAFE_INTEGER;
        });
    }
  });

  await Promise.all(pricePromises);
  tpItems.sort((a, b) => a._priceCopper - b._priceCopper);

  const rarityColorMap = {
    Junk: "#aaa",
    Basic: "#aaa",
    Fine: "#62a4da",
    Masterwork: "#1a9306",
    Rare: "#fcd00b",
    Exotic: "#ffa405",
    Ascended: "#fb3e8d",
    Legendary: "#4c139d"
  };

  const createEntryDiv = (entry) => {
    const div = document.createElement("div");
    div.className = "result";
    div.style.borderLeftColor = rarityColorMap[entry.rarity] || "#ccc";

    const title = document.createElement("h3");

    if (entry.icon) {
      const icon = document.createElement("img");
      icon.src = entry.icon;
      icon.className = "icon";
      title.appendChild(icon);
    }

    const nameSpan = document.createElement(entry.link ? "a" : "span");
    nameSpan.textContent = `Loading item name...`;
    if (entry.link) {
      nameSpan.href = entry.link;
      nameSpan.target = "_blank";
      nameSpan.style.color = "#0066cc";
      nameSpan.style.textDecoration = "none";
      nameSpan.style.display = "inline-flex";
      nameSpan.style.alignItems = "center";

      const extIcon = document.createElement("img");
      extIcon.src = "assets/external-link.png";
      extIcon.alt = "(external)";
      extIcon.style.height = "0.9em";
      extIcon.style.verticalAlign = "middle";
      extIcon.style.marginLeft = "0.3em";
      nameSpan.appendChild(extIcon);
    }
    title.appendChild(nameSpan);

    const meta = document.createElement("span");
    meta.style.fontSize = "0.9em";
    meta.style.color = "#666";
    meta.style.marginLeft = "0.5em";
    meta.textContent = `(${entry.rarity}${entry.weight_class ? ", " + entry.weight_class : ""})`;
    title.appendChild(meta);

const itemId = parseInt(entry.name);
if (!isNaN(itemId)) {
  if (itemNameCache[itemId]) {
    nameSpan.childNodes[0].nodeValue = itemNameCache[itemId];
  } else {
    fetchItemName(itemId).then(name => {
      nameSpan.childNodes[0].nodeValue = name;
    });
  }
}
 
    else {
      nameSpan.childNodes[0].nodeValue = entry.name;
    }

    div.appendChild(title);

    const method = document.createElement("p");
    method.innerHTML = `<strong>Method:</strong> ${entry.method}`;
    div.appendChild(method);

    if (entry.description) {
      const desc = document.createElement("p");
      desc.innerHTML = `<strong>Description:</strong> ${entry.description}`;
      div.appendChild(desc);
    }

    div.appendChild(createCostElement(entry));

    return div;
  };

  if (tpItems.length) {
    const h = document.createElement("h2");
    h.textContent = "Exotic (TP, sorted by price)";
    resultsDiv.appendChild(h);

    const tpWrapper = document.createElement("div");
    tpWrapper.style.position = "relative";

    const warning = document.createElement("p");
    warning.innerHTML = "⚠️ <strong>Warning:</strong> not a full TP search! Use ingame TP and filters to see it all! ⚠️";
    warning.style.background = "#fffbe6";
    warning.style.border = "1px solid #ffcc00";
    warning.style.borderRadius = "0.5rem";
    warning.style.padding = "0.5rem 1rem";
    warning.style.margin = "0.5rem 0 1rem 0";
    warning.style.color = "#664d00";
    warning.style.fontSize = "0.9em";
    tpWrapper.appendChild(warning);

    const topEntry = createEntryDiv(tpItems[0]);
    topEntry.style.boxShadow = "0 4px 8px rgba(0,0,0,0.15)";
    topEntry.style.marginBottom = "0.5rem";
    tpWrapper.appendChild(topEntry);

    const collapseDiv = document.createElement("div");
    collapseDiv.style.display = "none";
    tpItems.slice(1).forEach(entry => collapseDiv.appendChild(createEntryDiv(entry)));
    tpWrapper.appendChild(collapseDiv);

    const toggleBtn = document.createElement("button");
    toggleBtn.textContent = "Show more options";
    toggleBtn.style.background = "#fff";
    toggleBtn.style.border = "1px solid #ccc";
    toggleBtn.style.borderRadius = "0.5rem";
    toggleBtn.style.padding = "0.5rem 1rem";
    toggleBtn.style.cursor = "pointer";
    toggleBtn.style.margin = "0 auto 1rem auto";
    toggleBtn.style.display = "block";

    toggleBtn.addEventListener("click", () => {
      const isHidden = collapseDiv.style.display === "none";
      collapseDiv.style.display = isHidden ? "block" : "none";
      toggleBtn.textContent = isHidden ? "Hide extra options" : "Show more options";
    });

    tpWrapper.appendChild(toggleBtn);
    resultsDiv.appendChild(tpWrapper);
  }

  const exoticGroups = {};
  otherExotics.forEach(entry => {
    const group = entry.method || "Other";
    if (!exoticGroups[group]) exoticGroups[group] = [];
    exoticGroups[group].push(entry);
  });

  Object.entries(exoticGroups).sort().forEach(([method, group]) => {
    const h = document.createElement("h2");
    h.textContent = `Exotic via ${method}`;
    resultsDiv.appendChild(h);
    group.forEach(entry => resultsDiv.appendChild(createEntryDiv(entry)));
  });

  if (ascendedItems.length) {
    const h = document.createElement("h2");
    h.textContent = "Ascended";
    resultsDiv.appendChild(h);
    ascendedItems.forEach(entry => resultsDiv.appendChild(createEntryDiv(entry)));
  }

  if (legendaryItems.length) {
    const h = document.createElement("h2");
    h.textContent = "Legendary";
    resultsDiv.appendChild(h);
    legendaryItems.forEach(entry => resultsDiv.appendChild(createEntryDiv(entry)));
  }

  // STAT SWAP
  const isTrinketSlot = slotTypeMap[currentSlot]?.toLowerCase() === "trinkets";
  if (
    currentAttrLabel &&
    gearData[currentSlot] &&
    !isTrinketSlot &&
    (!filters.rarity.size || filters.rarity.has("Ascended"))
  ) {
    const existingAscendedItems = filteredItems.filter(
      item => item.rarity === "Ascended"
    );

//---> Filter
    const forgeableAscendedRaw = gearData[currentSlot].filter(entry =>
      entry.rarity === "Ascended" &&
      (!entry.attributes || entry.attributes.every(id => !attrIds.includes(String(id)))) &&
      (!filters.weight_class.size || (entry.weight_class && filters.weight_class.has(entry.weight_class)))
    );

    if (forgeableAscendedRaw.length > 0) {
      if (!document.querySelector(".stat-swap-header")) {
        const h = document.createElement("h2");
        const a = document.createElement("a");
        a.href = "https://wiki.guildwars2.com/wiki/Stat_changing#Ascended_weapons_and_armor";
        a.target = "_blank";
        a.style.color = "#0066cc";
        a.style.textDecoration = "none";
        a.innerHTML = `Ascended via Stat changing <img src="assets/external-link.png" style="height:0.9em; vertical-align:middle; margin-left:0.3em;">`;
        h.appendChild(a);
        h.classList.add("stat-swap-header");
        resultsDiv.appendChild(h);
      }

      // Direkt anzeigen
     forgeableAscendedRaw.forEach(entry => {
      const div = createEntryDiv(entry);
      div.classList.add("stat-swap-entry");
      if (entry.method === "Crafting") div.dataset.type = "crafting";
      resultsDiv.appendChild(div);
      });

      const loadingNote = document.createElement("p");
      loadingNote.textContent = "Calculating Crafting Items...";
      loadingNote.id = "statSwapLoading";
      loadingNote.style.color = "#888";
      loadingNote.style.fontSize = "0.9em";
      loadingNote.style.marginTop = "0.5em";
      resultsDiv.appendChild(loadingNote);

      (async () => {
        const withCost = await Promise.all(forgeableAscendedRaw.map(async item => {
          let costEstimate = Number.MAX_SAFE_INTEGER;
          let costKey = null;

          if (typeof item.cost === "string" && item.cost.startsWith("craft:")) {
            costKey = item.cost;
            costEstimate = await getCraftingCost(item.cost.slice(6));
          } else if (Array.isArray(item.cost)) {
            const craftEntry = item.cost.flat().find(frag => frag.currency?.startsWith("craft:"));
            if (craftEntry) {
              costKey = craftEntry.currency;
              costEstimate = await getCraftingCost(craftEntry.currency.slice(6));
            }
          }

          return { item, costEstimate, costKey };
        }));

        const grouped = new Map();
        for (const entry of withCost) {
          if (!entry.costKey || entry.costEstimate === Number.MAX_SAFE_INTEGER) continue;
          if (!grouped.has(entry.costKey) || entry.costEstimate < grouped.get(entry.costKey).costEstimate) {
            grouped.set(entry.costKey, entry);
          }
        }

        // Entferne nur die alten Crafting-Einträge
        document.querySelectorAll(".stat-swap-entry[data-type='crafting']").forEach(el => el.remove());
        document.getElementById("statSwapLoading")?.remove();

        // Zeige die besten Crafting-Optionen
        for (const { item } of grouped.values()) {
        const div = createEntryDiv(item);
        div.classList.add("stat-swap-entry");
        div.dataset.type = "crafting";
        resultsDiv.appendChild(div);
        }

      })();
    }
  }
}

function formatPrice(copper) {
  const c = copper % 100;
  const s = Math.floor((copper / 100) % 100);
  const g = Math.floor(copper / 10000);

  let parts = [];
  if (g > 0) parts.push(`${g}<img src='assets/gold.png' style='height:1em;'>`);
  if (s > 0 || (g > 0 && c > 0)) parts.push(`${s}<img src='assets/silver.png' style='height:1em;'>`);
  if (c > 0 || (g === 0 && s === 0)) parts.push(`${c}<img src='assets/copper.png' style='height:1em;'>`);

  return parts.join(" ");
}


const craftCostCache = {}; // 🧠 Caches die berechneten crafting-Kosten

async function fetchItemName(itemId) {
  if (itemNameCache[itemId]) return itemNameCache[itemId];

  try {
    const data = await rateLimitedFetch(`https://api.guildwars2.com/v2/items/${itemId}?lang=en`);
    const name = data?.name || `Item ID: ${itemId}`;
    itemNameCache[itemId] = name;
    return name;
  } catch {
    return `Item ID: ${itemId}`;
  }
}
    
async function getCraftingCost(itemId, depth = 0, visited = new Set()) {
  if (craftCostCache[itemId] !== undefined) return craftCostCache[itemId];
  if (depth > 10 || visited.has(itemId)) return Number.MAX_SAFE_INTEGER;
  visited.add(itemId);

  let tpCost = Number.MAX_SAFE_INTEGER;
  let coinCost = Number.MAX_SAFE_INTEGER;
  let craftCost = Number.MAX_SAFE_INTEGER;

  // 1. TP-Preis
  try {
    if (tpPriceCache[itemId]) {
      tpCost = tpPriceCache[itemId].copperValue;
    } else {
      const data = await rateLimitedFetch(`https://api.guildwars2.com/v2/commerce/prices/${itemId}`);
      tpCost = data?.buys?.unit_price ?? Number.MAX_SAFE_INTEGER;
      tpPriceCache[itemId] = {
        copperValue: tpCost,
        html: tpCost < Number.MAX_SAFE_INTEGER ? `<strong>Cost:</strong> ${formatPrice(tpCost)}` : `<strong>Cost:</strong> Unknown`
      };
    }
  } catch {
    tpCost = Number.MAX_SAFE_INTEGER;
    tpPriceCache[itemId] = {
      copperValue: tpCost,
      html: `<strong>Cost:</strong> Unknown`
    };
  }

  // 2. Vendor-Wert
  if (craftComponentsMap?.[itemId] !== undefined) {
    coinCost = craftComponentsMap[itemId];
  }

  // 3. Crafting aus Subkomponenten
  try {
    const recipeIds = await rateLimitedFetch(`https://api.guildwars2.com/v2/recipes/search?output=${itemId}`);
    if (Array.isArray(recipeIds) && recipeIds.length > 0) {
      const recipe = await rateLimitedFetch(`https://api.guildwars2.com/v2/recipes/${recipeIds[0]}`);
      let sum = 0;
      for (const ing of recipe.ingredients) {
        const subCost = await getCraftingCost(ing.item_id, depth + 1, new Set(visited));
        sum += subCost * ing.count;
      }
      craftCost = sum;
    }
  } catch {
    // kein Rezept → craftCost bleibt MAX_SAFE_INTEGER
  }

  // 4. Günstigsten Pfad wählen
  const best = Math.min(tpCost, coinCost, craftCost);
  if (best === Number.MAX_SAFE_INTEGER) {
    console.warn(`⚠️ No valid cost for item ${itemId}`);
  }

  craftCostCache[itemId] = best;
  return best;
}

    slotSelect.addEventListener("change", () => {
      currentSlot = slotSelect.value;
      attributeSelect.innerHTML = '';
      filtersDiv.innerHTML = "";
      resultsDiv.innerHTML = "";

      if (gearData[currentSlot]) {
        buildAttributeDropdown(currentSlot);
        // 🧠 Reset weight_class filter if the new slot has no weight_class entries
        if (!gearData[currentSlot].some(item => !!item.weight_class)) {
        filters.weight_class.clear();
        }
      }
      if (currentAttrLabel) {
      renderFilters(gearData[currentSlot]);
      renderItems();
      }
    });

    attributeSelect.addEventListener("change", () => {
      const selectedLabel = attributeSelect.options[attributeSelect.selectedIndex].textContent;
      currentAttrLabel = selectedLabel;
      filters.rarity.clear();
      filters.weight_class.clear();

     if (currentSlot && currentAttrLabel && gearData[currentSlot]) {
    const attrIds = Object.entries(attributeMap)
      .filter(([, label]) => label === currentAttrLabel)
      .map(([id]) => id);

    renderFilters(gearData[currentSlot]);
    renderItems();
      }
    });

    initialize();
  </script>
</body>
</html>
