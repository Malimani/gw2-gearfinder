<!DOCTYPE html>
<html lang="en">
<head>
  <script defer data-domain="gw2gear.com" src="https://plausible.io/js/script.js"></script>
  <meta charset="UTF-8" />
  <link rel="icon" href="assets/favicon.png" type="image/png">
  <title>Good Ways 2 Gear</title>
  <style>
body {
    font-family: sans-serif;
    background: #f0f0f0;
    padding: 2rem;
    display: flex;
    justify-content: center;
  }

  .container {
    max-width: 700px;
    width: 100%;
  }

  header {
    display: flex;
    align-items: center;
    gap: 1rem;
    margin-bottom: 2rem;
    flex-wrap: wrap;
  }

  header img {
    height: 48px;
  }

  header h1 {
    flex: 1;
    min-width: 200px;
    max-width: 100%;
  }

  h2 {
    font-size: 1.2em;
    margin-top: 2rem;
    margin-bottom: 0.5rem;
    color: #333;
    border-bottom: 1px solid #ddd;
    padding-bottom: 0.25rem;
  }

  select {
    margin-bottom: 1rem;
    padding: 0.5rem;
    width: 100%;
    max-width: 700px;
  }

  .filters {
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
    align-items: center;
    margin-bottom: 1rem;
  }

  .filter-group {
    display: flex;
    border-radius: 0.75rem;
    overflow: hidden;
    box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    background: white;
  }

  .filter-button {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0.5rem 1rem;
    background: white;
    color: #333;
    font-weight: bold;
    cursor: pointer;
    border: none;
    border-right: 1px solid #ddd;
    box-sizing: border-box;
    transition: background 0.2s, color 0.2s;
    min-width: 6em;
  }

  .filter-button:last-child {
    border-right: none;
  }

  .filter-button.active {
    background: #0066cc;
    color: white;
  }

  .filter-rarity.ascended {
    box-shadow: inset 6px 0 0 #fb3e8d;
  }

  .filter-rarity.exotic {
    box-shadow: inset -6px 0 0 #ffa405;
  }

  .filter-weight.light::after {
    content: " 🪶";
    font-size: 1em;
  }

  .filter-weight.medium::after {
    content: " ⚖️";
    font-size: 1em;
  }

  .filter-weight.heavy::after {
    content: " 🪨";
    font-size: 1em;
  }

  .filter-group.filter-rarity .filter-button,
  .filter-group.filter-weight .filter-button {
    min-width: 6.5em;
  }

  .reset-button,
  #filters > button {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 2.5em;
    padding: 0.5rem 1.25rem;
    border-radius: 0.75rem;
    border: 1px solid #ccc;
    background: white;
    font-weight: bold;
    box-shadow: 0 2px 6px rgba(0,0,0,0.08);
    cursor: pointer;
  }

  .result {
    background: white;
    padding: 6px 1rem;
    margin-top: 0.75rem;
    border-radius: 0.75rem;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
    border-left: 6px solid transparent;
    transition: transform 0.2s, box-shadow 0.2s;
  }

    .result:first-child.exotic-tp {
  box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
}

  .result:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  }

  .result h3 {
    margin-bottom: 0.5rem;
    font-size: 1.2em;
    display: flex;
    align-items: center;
    flex-wrap: wrap;
    gap: 0.4rem;
  }

  .result h3 .icon {
    height: 1.5em;
    vertical-align: middle;
  }

  .result p {
    margin: 0.3rem 0;
  }

  .result a {
    color: #0066cc;
    text-decoration: none;
  }

  .result a:hover {
    text-decoration: underline;
  }

  .result img.icon {
    height: 1.5em;
    vertical-align: middle;
    margin-right: 0.5em;
  }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <img src="assets/logo.png" alt="Logo">
      <h1>
        Good Ways 2 Gear
        <small style="font-size: 0.6em; color: #666;">v1.2.0 &nbsp;|&nbsp; <span id="itemCounter">Loading items...</span>
      </small>
      </h1>

      <p style="margin-top: -1rem; font-size: 0.9em; color: #444;">
        Inspired by Tanetris's in depth guide: <a href="https://wiki.guildwars2.com/wiki/User:Tanetris/So_You_Want_To_Gear_a_Character" target="_blank" style="color: #0066cc; text-decoration: underline;"><em>So You Want To Gear a Character</em> <img src="assets/external-link.png" alt="external link" style='height: 0.9em; vertical-align: middle; margin-left: 0.3em;'></a>
      </p>
    </header>

    <select id="slotSelect">
      <option value="">-- Select Gear Slot --</option>
    </select>
    <select id="attributeSelect" style="display: none;"></select>
    <div class="filters" id="filters"></div>
    <div id="results"></div>

    <footer style="margin-top: 3rem; font-size: 0.8em; color: #777; text-align: center;">
      <p>
        <a href="Legal.html">Legal</a> |
        <a href="https://discord.gg/dtxTBbQdhP" target="_blank">Join our Discord</a> |
        Fan project – not affiliated with ArenaNet
      </p>
    </footer>
  </div>

  <script>
    const itemNameCache = {}; // ✅ Cache für Itemnamen
    const tpPriceCache = {};  // ✅ Cache für TP-Preise
    const slotSelect = document.getElementById("slotSelect");
    const attributeSelect = document.getElementById("attributeSelect");
    const filtersDiv = document.getElementById("filters");
    const resultsDiv = document.getElementById("results");

    let gearData = {};
    let attributeMap = {};
    let filters = { rarity: new Set(), weight_class: new Set() };
    let currentSlot = "";
    let currentAttrLabel = "";
    let slotTypeMap = {};
    let currencyIconMap = {};

    async function loadSlotTypeMap() {
      try {
        const res = await fetch("slotTypeMap.json");
        slotTypeMap = await res.json();
      } catch (err) {
        console.error("Error loading slotTypeMap:", err);
      }
    }

    async function initialize() {
      try {
        const [attrRes, gearRes, slotMapRes, currencyRes] = await Promise.all([
          fetch("attributeMap.json"),
          fetch("gearData.json"),
          fetch("slotTypeMap.json"),
          fetch("currencyIconMap.json")
        ]);
        attributeMap = await attrRes.json();
        gearData = await gearRes.json();
        slotTypeMap = await slotMapRes.json();
        currencyIconMap = await currencyRes.json();  // ⬅️
        buildSlotDropdown();
        updateItemCounter();
      } catch (err) {
        console.error("Initialization error:", err);
      }
    }

    function updateItemCounter() {
      let itemCount = 0;
      for (const slot in gearData) {
        itemCount += gearData[slot].length;
        }
      const counterEl = document.getElementById("itemCounter");
      if (counterEl) {
        counterEl.textContent = `${itemCount} items`;
      }
    }

    function buildSlotDropdown() {
      const groupedSlots = {};
      for (const slot in gearData) {
        const group = slotTypeMap[slot] || "Other";
        if (!groupedSlots[group]) groupedSlots[group] = [];
        groupedSlots[group].push(slot);
      }
      for (const group of Object.keys(groupedSlots).sort()) {
        const optgroup = document.createElement("optgroup");
        optgroup.label = group;
        groupedSlots[group].sort().forEach(slot => {
          const option = document.createElement("option");
          option.value = slot;
          option.textContent = slot;
          optgroup.appendChild(option);
        });
        slotSelect.appendChild(optgroup);
      }
    }

    function buildAttributeDropdown(slot) {
      const seenLabels = new Set();
      const validOptions = [];
      const unknownOptions = [];
      attributeSelect.innerHTML = '<option value="">-- Select Attribute / Effect --</option>';
      const attrIds = new Set();
      gearData[slot].forEach(item => (item.attributes || []).forEach(id => attrIds.add(id.toString())));

      attrIds.forEach(id => {
        const label = attributeMap[id];
        const option = document.createElement("option");
        option.value = id;
        if (label) {
          if (!seenLabels.has(label)) {
            seenLabels.add(label);
            option.textContent = label;
            validOptions.push(option);
          }
        } else {
          option.textContent = `Attribute ${id}`;
          option.disabled = true;
          option.style.color = "#aaa";
          unknownOptions.push(option);
        }
      });

      [...validOptions.sort((a, b) => a.textContent.localeCompare(b.textContent)),
       ...unknownOptions.sort((a, b) => a.textContent.localeCompare(b.textContent))]
        .forEach(option => attributeSelect.appendChild(option));

      attributeSelect.style.display = 'block';
      for (let i = 0; i < attributeSelect.options.length; i++) {
      if (attributeSelect.options[i].textContent === currentAttrLabel) {
        attributeSelect.selectedIndex = i;
        break;
      }
    }
    }

    function renderFilters(items) {
      filtersDiv.innerHTML = "";
      const rarities = new Set();
      const weights = new Set();
      items.forEach(item => {
        if (item.rarity) rarities.add(item.rarity);
        if (item.weight_class) weights.add(item.weight_class);
      });

const createButton = (label, type) => {
  const btn = document.createElement("button");
  btn.textContent = label;
  btn.className = filters[type].has(label) ? "active" : "";

  btn.addEventListener("click", () => {
    const isExclusiveRarity = type === "rarity" && (label === "Ascended" || label === "Exotic");
    const isExclusiveWeight = type === "weight_class" && ["Light", "Medium", "Heavy"].includes(label);

    if (isExclusiveRarity || isExclusiveWeight) {
      // Exklusives Verhalten
      filters[type].clear();
      if (!btn.classList.contains("active")) {
        filters[type].add(label);
      }
    } else {
      // Fallback: normal togglen
      if (filters[type].has(label)) filters[type].delete(label);
      else filters[type].add(label);
    }

    const filteredItems = items.filter(entry =>
      (!filters.rarity.size || filters.rarity.has(entry.rarity)) &&
      (!filters.weight_class.size || (entry.weight_class && filters.weight_class.has(entry.weight_class)))
    );

    renderItems(filteredItems);
    renderFilters(items);
  });

  return btn;
};

// Rarity Group: Ascended + Exotic mit Farbbändern
const rarityGroup = document.createElement("div");
rarityGroup.className = "filter-group";

["Ascended", "Exotic"].forEach(r => {
  if (rarities.has(r)) {
    const btn = createButton(r, "rarity");
    btn.classList.add("filter-button", "filter-rarity");
    if (r === "Ascended") btn.classList.add("ascended");
    if (r === "Exotic") btn.classList.add("exotic");
    rarityGroup.appendChild(btn);
  }
});
filtersDiv.appendChild(rarityGroup);

// Weight Class Group: Light + Medium + Heavy mit Symbolen
const weightGroup = document.createElement("div");
weightGroup.className = "filter-group";

["Light", "Medium", "Heavy"].forEach(w => {
  if (weights.has(w)) {
    const btn = createButton(w, "weight_class");
    btn.classList.add("filter-button", "filter-weight", w.toLowerCase());
    weightGroup.appendChild(btn);
  }
});
filtersDiv.appendChild(weightGroup);


      if (rarities.size || weights.size) {
        const resetBtn = document.createElement("button");
        resetBtn.textContent = "Reset Filters";
        resetBtn.addEventListener("click", () => {
        filters.rarity.clear();
        filters.weight_class.clear();
        renderItems(items);
        renderFilters(items);
      });
        filtersDiv.appendChild(resetBtn);
      }
    }
   
function formatCurrency(input) {
  if (typeof input === "string") {
    const trimmed = input.trim();
    const match = trimmed.match(/^([0-9]+)([gsc])$/);
    if (match) {
      const amount = match[1];
      const unit = match[2];
      const iconMap = { g: "gold", s: "silver", c: "copper" };
      return `${amount}<img src='assets/${iconMap[unit]}.png' style='height:1em;'>`;
    }
    return trimmed.replaceAll("_", " ");
  }

  if (typeof input === "object" && input.currency && input.amount != null) {
    if (input.currency === "Coin") {
      const copper = input.amount;
      const g = Math.floor(copper / 10000);
      const s = Math.floor((copper % 10000) / 100);
      const c = copper % 100;

      let parts = [];
      if (g > 0) parts.push(`${g}<img src='assets/gold.png' style='height:1em;'>`);
      if (s > 0 || g > 0) parts.push(`${s}<img src='assets/silver.png' style='height:1em;'>`);
      if (c > 0 || (g === 0 && s === 0)) parts.push(`${c}<img src='assets/copper.png' style='height:1em;'>`);

      return parts.join(" ");
    }
    else if (currencyIconMap[input.currency]) {
  const icon = typeof currencyIconMap[input.currency] === "string"
    ? currencyIconMap[input.currency]
    : currencyIconMap[input.currency].icon;

  return `${input.amount.toLocaleString()} <img src='assets/${icon}' title='${input.currency.replaceAll("_", " ")}' style='height:1em; vertical-align:middle;'>`;
} else {
  return `${input.amount.toLocaleString()} ${input.currency.replaceAll("_", " ")}`;
}

    return `${input.amount.toLocaleString()} ${input.currency.replaceAll("_", " ")}`;
  }

  return String(input);
}

function createCostElement(entry) {
  const cost = document.createElement("p");

  if (!entry.cost || (Array.isArray(entry.cost) && entry.cost.length === 0)) {
    return document.createComment("No cost to display");
  }

  if (typeof entry.cost === "string" && entry.cost.startsWith("TP:")) {
    const tpId = entry.cost.slice(3);
    cost.innerHTML = tpPriceCache[tpId]?.html || `<strong>Cost:</strong> loading...`;
  } else if (typeof entry.cost === "string" && entry.cost.startsWith("craft:")) {
  const craftId = entry.cost.slice(6);
  cost.innerHTML = `<strong>Cost:</strong> calculating...`;

  getCraftingCost(craftId).then(copper => {
    if (copper < Number.MAX_SAFE_INTEGER) {
      cost.innerHTML = `<strong>Cost:</strong> ${formatPrice(copper)}`;
    } else {
      cost.innerHTML = `<strong>Cost:</strong> Unknown`;
    }
  });
}
  else if (Array.isArray(entry.cost)) {
    const formattedOptions = entry.cost.map(optionArr =>
      optionArr.map(fragment => formatCurrency(fragment)).join(" + ")
    );
    cost.innerHTML = `<strong>Cost:</strong> ${formattedOptions.join(" <span style='color:#666;'>/</span> ")}`;
  } else {
    cost.innerHTML = `<strong>Cost:</strong> ${entry.cost}`;
  }

  return cost;
}

  
async function renderItems(items = gearData[currentSlot]) {
  resultsDiv.innerHTML = "";
  if (!currentSlot || !gearData[currentSlot]) return;

  const attrIds = Object.entries(attributeMap)
    .filter(([, label]) => label.trim() === currentAttrLabel.trim())
    .map(([id]) => id);

  const filteredItems = items.filter(entry => {
    if (currentAttrLabel && (!entry.attributes || !entry.attributes.some(id => attrIds.includes(String(id))))) return false;
    if (filters.rarity.size && !filters.rarity.has(entry.rarity)) return false;
    if (filters.weight_class.size && (!entry.weight_class || !filters.weight_class.has(entry.weight_class))) return false;
    return true;
  });

  const tpItems = [];
  const otherExotics = [];
  const ascendedItems = [];
  const legendaryItems = [];

  for (const entry of filteredItems) {
    const isTP = typeof entry.cost === "string" && entry.cost.startsWith("TP:");
    if (entry.rarity === "Exotic" && isTP) {
      tpItems.push(entry);
    } else if (entry.rarity === "Exotic") {
      otherExotics.push(entry);
    } else if (entry.rarity === "Ascended") {
      ascendedItems.push(entry);
    } else if (entry.rarity === "Legendary") {
      legendaryItems.push(entry);
    }
  }

  const pricePromises = tpItems.map(entry => {
    const tpId = entry.cost.slice(3);
    if (tpPriceCache[tpId]) {
      entry._priceCopper = tpPriceCache[tpId].copperValue;
      return Promise.resolve();
    } else {
      return fetch(`https://api.guildwars2.com/v2/commerce/prices/${tpId}`)
        .then(res => res.json())
        .then(data => {
          const priceCopper = data.sells.unit_price;
          entry._priceCopper = priceCopper;
          tpPriceCache[tpId] = {
            html: `<strong>Cost:</strong> ${formatPrice(priceCopper)}`,
            copperValue: priceCopper
          };
        })
        .catch(() => {
          entry._priceCopper = Number.MAX_SAFE_INTEGER;
        });
    }
  });

  await Promise.all(pricePromises);
  tpItems.sort((a, b) => a._priceCopper - b._priceCopper);

  const rarityColorMap = {
    Junk: "#aaa",
    Basic: "#aaa",
    Fine: "#62a4da",
    Masterwork: "#1a9306",
    Rare: "#fcd00b",
    Exotic: "#ffa405",
    Ascended: "#fb3e8d",
    Legendary: "#4c139d"
  };

const createEntryDiv = (entry) => {
  const div = document.createElement("div");
  div.className = "result";
  div.style.borderLeftColor = rarityColorMap[entry.rarity] || "#ccc";

  const title = document.createElement("h3");

  if (entry.icon) {
    const icon = document.createElement("img");
    icon.src = entry.icon;
    icon.className = "icon";
    title.appendChild(icon);
  }

  const nameSpan = document.createElement(entry.link ? "a" : "span");
  nameSpan.textContent = `Loading item name...`;
  if (entry.link) {
    nameSpan.href = entry.link;
    nameSpan.target = "_blank";
    nameSpan.style.color = "#0066cc";
    nameSpan.style.textDecoration = "none";
    nameSpan.style.display = "inline-flex";
    nameSpan.style.alignItems = "center";

    const extIcon = document.createElement("img");
    extIcon.src = "assets/external-link.png";
    extIcon.alt = "(external)";
    extIcon.style.height = "0.9em";
    extIcon.style.verticalAlign = "middle";
    extIcon.style.marginLeft = "0.3em";
    nameSpan.appendChild(extIcon);
  }
  title.appendChild(nameSpan);

  const meta = document.createElement("span");
  meta.style.fontSize = "0.9em";
  meta.style.color = "#666";
  meta.style.marginLeft = "0.5em";
  meta.textContent = `(${entry.rarity}${entry.weight_class ? ", " + entry.weight_class : ""})`;
  title.appendChild(meta);

  const itemId = parseInt(entry.name);
  if (!isNaN(itemId)) {
    if (itemNameCache[itemId]) {
      nameSpan.childNodes[0].nodeValue = itemNameCache[itemId];
    } else {
      fetch(`https://api.guildwars2.com/v2/items/${itemId}?lang=en`)
        .then(res => res.json())
        .then(data => {
          const name = data?.name || `Item ID: ${entry.name}`;
          itemNameCache[itemId] = name;
          nameSpan.childNodes[0].nodeValue = name;
        })
        .catch(() => {
          nameSpan.childNodes[0].nodeValue = `Item ID: ${entry.name}`;
        });
    }
  } else {
    nameSpan.childNodes[0].nodeValue = entry.name;
  }

  div.appendChild(title);

  const method = document.createElement("p");
  method.innerHTML = `<strong>Method:</strong> ${entry.method}`;
  div.appendChild(method);

  if (entry.description) {
    const desc = document.createElement("p");
    desc.innerHTML = `<strong>Description:</strong> ${entry.description}`;
    div.appendChild(desc);
  }

  div.appendChild(createCostElement(entry));

  return div;
};

  if (tpItems.length) {
  const h = document.createElement("h2");
  h.textContent = "Exotic (TP, sorted by price)";
  resultsDiv.appendChild(h);

  // Wrapper für alle TP-Einträge
  const tpWrapper = document.createElement("div");
  tpWrapper.style.position = "relative";

  // Top TP-Item
  const topEntry = createEntryDiv(tpItems[0]);
  topEntry.style.boxShadow = "0 4px 8px rgba(0,0,0,0.15)";
  topEntry.style.marginBottom = "0.5rem";
  tpWrapper.appendChild(topEntry);

  // Collapsible Container
  const collapseDiv = document.createElement("div");
  collapseDiv.style.display = "none";
  tpItems.slice(1).forEach(entry => collapseDiv.appendChild(createEntryDiv(entry)));
  tpWrapper.appendChild(collapseDiv);

  // Toggle Button
  const toggleBtn = document.createElement("button");
  toggleBtn.textContent = "Show more options";
  toggleBtn.style.background = "#fff";
  toggleBtn.style.border = "1px solid #ccc";
  toggleBtn.style.borderRadius = "0.5rem";
  toggleBtn.style.padding = "0.5rem 1rem";
  toggleBtn.style.cursor = "pointer";
  toggleBtn.style.margin = "0 auto 1rem auto";
  toggleBtn.style.display = "block";

  toggleBtn.addEventListener("click", () => {
    const isHidden = collapseDiv.style.display === "none";
    collapseDiv.style.display = isHidden ? "block" : "none";
    toggleBtn.textContent = isHidden ? "Hide extra options" : "Show more options";
  });

  tpWrapper.appendChild(toggleBtn);
  resultsDiv.appendChild(tpWrapper);
}

  const exoticGroups = {};
  otherExotics.forEach(entry => {
    const group = entry.method || "Other";
    if (!exoticGroups[group]) exoticGroups[group] = [];
    exoticGroups[group].push(entry);
  });

  Object.entries(exoticGroups).sort().forEach(([method, group]) => {
    const h = document.createElement("h2");
    h.textContent = `Exotic via ${method}`;
    resultsDiv.appendChild(h);
    group.forEach(entry => resultsDiv.appendChild(createEntryDiv(entry)));
  });

  if (ascendedItems.length) {
    const h = document.createElement("h2");
    h.textContent = "Ascended";
    resultsDiv.appendChild(h);
    ascendedItems.forEach(entry => resultsDiv.appendChild(createEntryDiv(entry)));
  }

  if (legendaryItems.length) {
    const h = document.createElement("h2");
    h.textContent = "Legendary";
    resultsDiv.appendChild(h);
    legendaryItems.forEach(entry => resultsDiv.appendChild(createEntryDiv(entry)));
  }

function normalizeCostOption(option) {
  return option
    .map(c => typeof c === "string" ? c : `${c.currency}:${c.amount}`)
    .sort()
    .join("|");
}

function extractCostVariants(entry) {
  if (typeof entry.cost === "string") {
    return [entry.cost];
  }
  if (Array.isArray(entry.cost)) {
    return entry.cost.map(normalizeCostOption);
  }
  return [];
}

function hasSameCostOption(entryA, entryB) {
  const costA = new Set(extractCostVariants(entryA));
  const costB = extractCostVariants(entryB);
  return costB.some(variant => costA.has(variant));
}

const isTrinketSlot = slotTypeMap[currentSlot]?.toLowerCase() === "trinkets";
const rarityFilter = filters.rarity;

if (
  currentAttrLabel &&
  gearData[currentSlot] &&
  !isTrinketSlot &&
  (!rarityFilter.size || rarityFilter.has("Ascended"))
) {
  const existingAscendedItems = filteredItems.filter(
    item => item.rarity === "Ascended"
  );

  const forgeableAscended = gearData[currentSlot].filter(entry =>
    entry.rarity === "Ascended" &&
    (!entry.attributes || !entry.attributes.some(id => attrIds.includes(String(id)))) &&
    !existingAscendedItems.some(existing => hasSameCostOption(existing, entry))
  );

  if (forgeableAscended.length) {
    const h = document.createElement("h2");
    const a = document.createElement("a");
    a.href = "https://wiki.guildwars2.com/wiki/Stat_changing#Ascended_weapons_and_armor";
    a.target = "_blank";
    a.style.color = "#0066cc";
    a.style.textDecoration = "none";
    a.innerHTML = `Ascended via Stat changing <img src="assets/external-link.png" style="height:0.9em; vertical-align:middle; margin-left:0.3em;">`;
    h.appendChild(a);
    resultsDiv.appendChild(h);

    forgeableAscended.forEach(entry => {
      resultsDiv.appendChild(createEntryDiv(entry));
    });
  }
}

  
}

    function formatPrice(copper) {
  const c = copper % 100;
  const s = Math.floor((copper / 100) % 100);
  const g = Math.floor(copper / 10000);
  return `${g}<img src='assets/gold.png' style='height:1em;'> ${s}<img src='assets/silver.png' style='height:1em;'> ${c}<img src='assets/copper.png' style='height:1em;'>`;
}
async function getCraftingCost(itemId, depth = 0, visited = new Set()) {
  if (depth > 10 || visited.has(itemId)) {
    console.warn("Too deep or circular crafting chain at", itemId);
    return Number.MAX_SAFE_INTEGER;
  }
  visited.add(itemId);

  try {
    // 1. Versuche TP-Preis
    let unitCost = Number.MAX_SAFE_INTEGER;
    if (tpPriceCache[itemId]) {
      unitCost = tpPriceCache[itemId].copperValue;
    } else {
      try {
        const priceRes = await fetch(`https://api.guildwars2.com/v2/commerce/prices/${itemId}`);
        const priceData = await priceRes.json();
        unitCost = priceData.sells.unit_price;
        tpPriceCache[itemId] = { copperValue: unitCost };
      } catch {
        // TP-Preis nicht vorhanden → gehe zu Rezeptprüfung
      }
    }

    if (isFinite(unitCost) && unitCost > 0 && unitCost < Number.MAX_SAFE_INTEGER) {
      return unitCost;
    }

    // 2. Versuche Crafting-Rezept
    const recipeSearch = await fetch(`https://api.guildwars2.com/v2/recipes/search?output=${itemId}`);
    const recipeIds = await recipeSearch.json();
    if (!recipeIds.length) {
      console.warn("No TP price and no recipe for", itemId);
      return Number.MAX_SAFE_INTEGER;
    }

    const recipeId = recipeIds[0];
    const recipe = await fetch(`https://api.guildwars2.com/v2/recipes/${recipeId}`).then(r => r.json());

    let totalCost = 0;
    for (const ing of recipe.ingredients) {
      const ingCost = await getCraftingCost(ing.item_id, depth + 1, new Set(visited));
      totalCost += ing.count * ingCost;
    }

    return totalCost;
  } catch (e) {
    console.error("Crafting cost error for item", itemId, e);
    return Number.MAX_SAFE_INTEGER;
  }
}

    slotSelect.addEventListener("change", () => {
      currentSlot = slotSelect.value;
      attributeSelect.innerHTML = '';
      filtersDiv.innerHTML = "";
      resultsDiv.innerHTML = "";

      if (gearData[currentSlot]) {
        buildAttributeDropdown(currentSlot);
      }
      if (currentAttrLabel) {
      renderFilters(gearData[currentSlot]);
      renderItems();
      }
    });

    attributeSelect.addEventListener("change", () => {
      const selectedLabel = attributeSelect.options[attributeSelect.selectedIndex].textContent;
      currentAttrLabel = selectedLabel;
      filters.rarity.clear();
      filters.weight_class.clear();

     if (currentSlot && currentAttrLabel && gearData[currentSlot]) {
    const attrIds = Object.entries(attributeMap)
      .filter(([, label]) => label === currentAttrLabel)
      .map(([id]) => id);

    renderFilters(gearData[currentSlot]);
    renderItems();
      }
    });

    initialize();
  </script>
</body>
</html>
