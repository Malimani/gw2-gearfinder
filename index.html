<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <link rel="icon" href="assets/favicon.png" type="image/png">
  <title>Good Ways 2 Gear</title>
  <style>
    body {
      font-family: sans-serif;
      background: #f0f0f0;
      padding: 2rem;
      display: flex;
      justify-content: center;
    }
    .container {
      max-width: 700px;
      width: 100%;
    }
    header {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin-bottom: 2rem;
      flex-wrap: wrap;
    }
    header img {
      height: 48px;
    }
    header h1 {
      flex: 1;
      min-width: 200px;
      max-width: 100%;
    }
    h2 {
      font-size: 1.2em;
      margin-top: 2rem;
      margin-bottom: 0.5rem;
      color: #333;
      border-bottom: 1px solid #ddd;
      padding-bottom: 0.25rem;
    }
    select {
      margin-bottom: 1rem;
      padding: 0.5rem;
      width: 100%;
      max-width: 700px;
    }
    .filters {
      margin-bottom: 1rem;
    }
    .filters button {
      margin: 0rem 0.75rem 0rem 0rem;
      padding: 0.5rem 1rem;
      border: 1px solid #ccc;
      border-radius: 0.25rem;
      background: #fff;
      cursor: pointer;
    }
    .filters button.active {
      background-color: #0066cc;
      color: white;
      border-color: #0066cc;
    }
    .result img.icon {
      height: 1.5em;
      vertical-align: middle;
      margin-right: 0.5em;
    }
    .result h3 {
      margin: 0 0 0.5rem 0;
      font-size: 1.2em;
    }
    .result p {
      margin: 0.25rem 0;
    }
    .result a {
      color: #0066cc;
    }
    .result {
      background: white;
      padding: 1rem;
      margin-top: 0.75rem;
      border-radius: 0.75rem;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
      border-left: 6px solid transparent;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    .result:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }
    .result h3 {
      margin-bottom: 0.5rem;
      font-size: 1.2em;
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      gap: 0.4rem;
    }
    .result h3 .icon {
      height: 1.5em;
      vertical-align: middle;
    }
    .result p {
      margin: 0.3rem 0;
    }
    .result a {
      color: #0066cc;
    text-decoration: none;
    }
    .result a:hover {
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <img src="assets/logo.png" alt="Logo">
      <h1>
        Good Ways 2 Gear
        <small style="font-size: 0.6em; color: #666;">v1.2.0 &nbsp;|&nbsp; <span id="itemCounter">Loading items...</span>
      </small>
      </h1>

      <p style="margin-top: -1rem; font-size: 0.9em; color: #444;">
        Inspired by Tanetris's in depth guide: <a href="https://wiki.guildwars2.com/wiki/User:Tanetris/So_You_Want_To_Gear_a_Character" target="_blank" style="color: #0066cc; text-decoration: underline;"><em>So You Want To Gear a Character</em> <img src="assets/external-link.png" alt="external link" style='height: 0.9em; vertical-align: middle; margin-left: 0.3em;'></a>
      </p>
    </header>

    <select id="slotSelect">
      <option value="">-- Select Gear Slot --</option>
    </select>
    <select id="attributeSelect" style="display: none;"></select>
    <div class="filters" id="filters"></div>
    <div id="results"></div>

    <footer style="margin-top: 3rem; font-size: 0.8em; color: #777; text-align: center;">
      <p>
        <a href="impressum.html">Impressum</a> |
        <a href="datenschutz.html">Datenschutz</a> |
        Fan project – not affiliated with ArenaNet
      </p>
    </footer>
  </div>

  <script>
    const itemNameCache = {}; // ✅ Cache für Itemnamen
    const tpPriceCache = {};  // ✅ Cache für TP-Preise
    const slotSelect = document.getElementById("slotSelect");
    const attributeSelect = document.getElementById("attributeSelect");
    const filtersDiv = document.getElementById("filters");
    const resultsDiv = document.getElementById("results");

    let gearData = {};
    let attributeMap = {};
    let filters = { rarity: new Set(), weight_class: new Set() };
    let currentSlot = "";
    let currentAttrLabel = "";

    let slotTypeMap = {};

    async function loadSlotTypeMap() {
      try {
        const res = await fetch("slotTypeMap.json");
        slotTypeMap = await res.json();
      } catch (err) {
        console.error("Error loading slotTypeMap:", err);
      }
    }

    async function initialize() {
      try {
        const [attrRes, gearRes, slotMapRes] = await Promise.all([
          fetch("attributeMap.json"),
          fetch("gearData.json"),
          fetch("slotTypeMap.json")
        ]);
        attributeMap = await attrRes.json();
        gearData = await gearRes.json();
        slotTypeMap = await slotMapRes.json();
        buildSlotDropdown();
        updateItemCounter();
      } catch (err) {
        console.error("Initialization error:", err);
      }
    }

    function updateItemCounter() {
      let itemCount = 0;
      for (const slot in gearData) {
        itemCount += gearData[slot].length;
        }
      const counterEl = document.getElementById("itemCounter");
      if (counterEl) {
        counterEl.textContent = `${itemCount} items`;
      }
    }

    function buildSlotDropdown() {
      const groupedSlots = {};
      for (const slot in gearData) {
        const group = slotTypeMap[slot] || "Other";
        if (!groupedSlots[group]) groupedSlots[group] = [];
        groupedSlots[group].push(slot);
      }
      for (const group of Object.keys(groupedSlots).sort()) {
        const optgroup = document.createElement("optgroup");
        optgroup.label = group;
        groupedSlots[group].sort().forEach(slot => {
          const option = document.createElement("option");
          option.value = slot;
          option.textContent = slot;
          optgroup.appendChild(option);
        });
        slotSelect.appendChild(optgroup);
      }
    }

    function buildAttributeDropdown(slot) {
      const seenLabels = new Set();
      const validOptions = [];
      const unknownOptions = [];
      attributeSelect.innerHTML = '<option value="">-- Select Attribute / Effect --</option>';
      const attrIds = new Set();
      gearData[slot].forEach(item => (item.attributes || []).forEach(id => attrIds.add(id.toString())));

      attrIds.forEach(id => {
        const label = attributeMap[id];
        const option = document.createElement("option");
        option.value = id;
        if (label) {
          if (!seenLabels.has(label)) {
            seenLabels.add(label);
            option.textContent = label;
            validOptions.push(option);
          }
        } else {
          option.textContent = `Attribute ${id}`;
          option.disabled = true;
          option.style.color = "#aaa";
          unknownOptions.push(option);
        }
      });

      [...validOptions.sort((a, b) => a.textContent.localeCompare(b.textContent)),
       ...unknownOptions.sort((a, b) => a.textContent.localeCompare(b.textContent))]
        .forEach(option => attributeSelect.appendChild(option));

      attributeSelect.style.display = 'block';
    }

    function renderFilters(items) {
      filtersDiv.innerHTML = "";
      const rarities = new Set();
      const weights = new Set();
      items.forEach(item => {
        if (item.rarity) rarities.add(item.rarity);
        if (item.weight_class) weights.add(item.weight_class);
      });

      const createButton = (label, type) => {
        const btn = document.createElement("button");
        btn.textContent = label;
        btn.className = filters[type].has(label) ? "active" : "";
        btn.addEventListener("click", () => {
        if (filters[type].has(label)) filters[type].delete(label);
        else filters[type].add(label);
        const filteredItems = items.filter(entry =>
          (!filters.rarity.size || filters.rarity.has(entry.rarity)) &&
          (!filters.weight_class.size || (entry.weight_class && filters.weight_class.has(entry.weight_class)))
        );
        renderItems(filteredItems);
        renderFilters(items);
        });
        return btn;
      };

      rarities.forEach(r => filtersDiv.appendChild(createButton(r, "rarity")));
      weights.forEach(w => filtersDiv.appendChild(createButton(w, "weight_class")));

      if (rarities.size || weights.size) {
        const resetBtn = document.createElement("button");
        resetBtn.textContent = "Reset Filters";
        resetBtn.addEventListener("click", () => {
        filters.rarity.clear();
        filters.weight_class.clear();
        renderItems(items);
        renderFilters(items);
      });
        filtersDiv.appendChild(resetBtn);
      }
    }
   
function formatCurrency(input) {
      const trimmed = input.trim();
      const match = trimmed.match(/^([0-9]+)([gsc])$/);
      if (match) {
        const amount = match[1];
        const unit = match[2];
        const iconMap = { g: "gold", s: "silver", c: "copper" };
        return `${amount}<img src='assets/${iconMap[unit]}.png' style='height:1em;'>`;
      }
      return trimmed.replaceAll("_", " ");
    }

    function createCostElement(entry) {
      const cost = document.createElement("p");
      if (typeof entry.cost === "string" && entry.cost.startsWith("TP:")) {
        const tpId = entry.cost.slice(3);
        cost.innerHTML = tpPriceCache[tpId]?.html || `<strong>Cost:</strong> loading...`;
      } else if (Array.isArray(entry.cost)) {
        const formattedOptions = entry.cost.map(optionArr =>
          optionArr.map(fragment => formatCurrency(fragment)).join(" + ")
        );
        cost.innerHTML = `<strong>Cost:</strong> ${formattedOptions.join(" <span style='color:#666;'>/</span> ")}`;
      } else {
        cost.innerHTML = `<strong>Cost:</strong> ${entry.cost}`;
      }
      return cost;
    }
  
async function renderItems(items = gearData[currentSlot]) {
  resultsDiv.innerHTML = "";
  if (!currentSlot || !gearData[currentSlot]) return;

  const attrIds = Object.entries(attributeMap)
    .filter(([, label]) => label.trim() === currentAttrLabel.trim())
    .map(([id]) => id);

  const filteredItems = items.filter(entry => {
    if (currentAttrLabel && (!entry.attributes || !entry.attributes.some(id => attrIds.includes(String(id))))) return false;
    if (filters.rarity.size && !filters.rarity.has(entry.rarity)) return false;
    if (filters.weight_class.size && (!entry.weight_class || !filters.weight_class.has(entry.weight_class))) return false;
    return true;
  });

  const tpItems = [];
  const otherExotics = [];
  const ascendedItems = [];
  const legendaryItems = [];

  for (const entry of filteredItems) {
    const isTP = typeof entry.cost === "string" && entry.cost.startsWith("TP:");
    if (entry.rarity === "Exotic" && isTP) {
      tpItems.push(entry);
    } else if (entry.rarity === "Exotic") {
      otherExotics.push(entry);
    } else if (entry.rarity === "Ascended") {
      ascendedItems.push(entry);
    } else if (entry.rarity === "Legendary") {
      legendaryItems.push(entry);
    }
  }

  const pricePromises = tpItems.map(entry => {
    const tpId = entry.cost.slice(3);
    if (tpPriceCache[tpId]) {
      entry._priceCopper = tpPriceCache[tpId].copperValue;
      return Promise.resolve();
    } else {
      return fetch(`https://api.guildwars2.com/v2/commerce/prices/${tpId}`)
        .then(res => res.json())
        .then(data => {
          const priceCopper = data.sells.unit_price;
          entry._priceCopper = priceCopper;
          tpPriceCache[tpId] = {
            html: `<strong>Cost:</strong> ${formatPrice(priceCopper)}`,
            copperValue: priceCopper
          };
        })
        .catch(() => {
          entry._priceCopper = Number.MAX_SAFE_INTEGER;
        });
    }
  });

  await Promise.all(pricePromises);
  tpItems.sort((a, b) => a._priceCopper - b._priceCopper);

  const rarityColorMap = {
    Junk: "#aaa",
    Basic: "#aaa",
    Fine: "#62a4da",
    Masterwork: "#1a9306",
    Rare: "#fcd00b",
    Exotic: "#ffa405",
    Ascended: "#fb3e8d",
    Legendary: "#4c139d"
  };

  const createEntryDiv = (entry) => {
    const div = document.createElement("div");
    div.className = "result";
    div.style.borderLeftColor = rarityColorMap[entry.rarity] || "#ccc";

    const title = document.createElement("h3");

    if (entry.icon) {
      const icon = document.createElement("img");
      icon.src = entry.icon;
      icon.className = "icon";
      title.appendChild(icon);
    }

    const nameSpan = document.createElement("span");
    nameSpan.textContent = `Loading item name...`;
    title.appendChild(nameSpan);

    const meta = document.createElement("span");
    meta.style.fontSize = "0.9em";
    meta.style.color = "#666";
    meta.style.marginLeft = "0.5em";
    meta.textContent = `(${entry.rarity}${entry.weight_class ? ", " + entry.weight_class : ""})`;
    title.appendChild(meta);

    const itemId = parseInt(entry.name);
    if (!isNaN(itemId)) {
      if (itemNameCache[itemId]) {
        nameSpan.textContent = itemNameCache[itemId];
      } else {
        fetch(`https://api.guildwars2.com/v2/items/${itemId}?lang=en`)
          .then(res => res.json())
          .then(data => {
            const name = data?.name || `Item ID: ${entry.name}`;
            itemNameCache[itemId] = name;
            nameSpan.textContent = name;
          })
          .catch(() => {
            nameSpan.textContent = `Item ID: ${entry.name}`;
          });
      }
    } else {
      nameSpan.textContent = entry.name;
    }

    div.appendChild(title);

    const method = document.createElement("p");
    method.innerHTML = `<strong>Method:</strong> ${entry.method}`;
    div.appendChild(method);

    if (entry.description) {
      const desc = document.createElement("p");
      desc.innerHTML = `<strong>Description:</strong> ${entry.description}`;
      div.appendChild(desc);
    }

   div.appendChild(createCostElement(entry));

    if (entry.link) {
      const link = document.createElement("a");
      link.href = entry.link;
      link.textContent = "More info";
      link.target = "_blank";
      const externalIcon = document.createElement("img");
      externalIcon.src = "assets/external-link.png";
      externalIcon.alt = "(external)";
      externalIcon.style.height = "0.9em";
      externalIcon.style.verticalAlign = "middle";
      externalIcon.style.marginLeft = "0.3em";
      link.appendChild(externalIcon);
      div.appendChild(link);
    }

    return div;
  };

  if (tpItems.length) {
    const h = document.createElement("h2");
    h.textContent = "Exotic (TP, sorted by price)";
    resultsDiv.appendChild(h);
    tpItems.forEach(entry => resultsDiv.appendChild(createEntryDiv(entry)));
  }

  const exoticGroups = {};
  otherExotics.forEach(entry => {
    const group = entry.method || "Other";
    if (!exoticGroups[group]) exoticGroups[group] = [];
    exoticGroups[group].push(entry);
  });

  Object.entries(exoticGroups).sort().forEach(([method, group]) => {
    const h = document.createElement("h2");
    h.textContent = `Exotic via ${method}`;
    resultsDiv.appendChild(h);
    group.forEach(entry => resultsDiv.appendChild(createEntryDiv(entry)));
  });

  if (ascendedItems.length) {
    const h = document.createElement("h2");
    h.textContent = "Ascended";
    resultsDiv.appendChild(h);
    ascendedItems.forEach(entry => resultsDiv.appendChild(createEntryDiv(entry)));
  }

  if (legendaryItems.length) {
    const h = document.createElement("h2");
    h.textContent = "Legendary";
    resultsDiv.appendChild(h);
    legendaryItems.forEach(entry => resultsDiv.appendChild(createEntryDiv(entry)));
  }
}

    function formatPrice(copper) {
  const c = copper % 100;
  const s = Math.floor((copper / 100) % 100);
  const g = Math.floor(copper / 10000);
  return `${g}<img src='assets/gold.png' style='height:1em;'> ${s}<img src='assets/silver.png' style='height:1em;'> ${c}<img src='assets/copper.png' style='height:1em;'>`;
}

    slotSelect.addEventListener("change", () => {
      currentSlot = slotSelect.value;
      currentAttrLabel = "";
      attributeSelect.innerHTML = '';
      filtersDiv.innerHTML = "";
      resultsDiv.innerHTML = "";

      if (gearData[currentSlot]) {
        buildAttributeDropdown(currentSlot);
      }
    });

    attributeSelect.addEventListener("change", () => {
      const selectedLabel = attributeSelect.options[attributeSelect.selectedIndex].textContent;
      currentAttrLabel = selectedLabel;
      filters.rarity.clear();
      filters.weight_class.clear();

     if (currentSlot && currentAttrLabel && gearData[currentSlot]) {
    const attrIds = Object.entries(attributeMap)
      .filter(([, label]) => label === currentAttrLabel)
      .map(([id]) => id);

    console.log("Slot:", currentSlot);
    console.log("Selected attribute label:", currentAttrLabel);
    console.log("Resolved attrIds:", attrIds);

    renderFilters(gearData[currentSlot]);
    renderItems();
      }
    });

    initialize();
  </script>
</body>
</html>
