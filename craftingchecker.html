<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Crafting Checker</title>
  <style>
    body {
      font-family: sans-serif;
      background: #f9f9f9;
      padding: 2rem;
      max-width: 800px;
      margin: auto;
    }
    label, input, button {
      font-size: 1rem;
      margin: 0.5rem 0;
    }
    .node {
      margin-left: 1.5rem;
      border-left: 2px dashed #ccc;
      padding-left: 0.75rem;
    }
    .existing {
      color: #aaa;
    }
    .price-field {
      width: 6em;
      margin-left: 0.5rem;
    }
    .tp-price {
      margin-left: 0.5rem;
      font-size: 0.9em;
      color: #666;
    }
    .toggle {
      cursor: pointer;
      margin-right: 0.25rem;
      font-weight: bold;
    }
    .collapsed > .children {
      display: none;
    }
    pre {
      background: #eee;
      padding: 1rem;
      margin-top: 2rem;
      white-space: pre-wrap;
    }
    .warning {
      color: red;
      font-weight: bold;
      margin-top: 0.5rem;
    }
  </style>
</head>
<body>
  <h1>Crafting Checker</h1>
  <label for="itemId">Item ID:</label>
  <input type="text" id="itemId" placeholder="e.g. 19925">
  <button id="loadBtn">Load Tree</button>

  <div id="tree"></div>
  <button id="generateBtn">Generate JSON</button>
  <pre id="output"></pre>
  <h2>Estimated Total Cost</h2>
  <div id="totalCost"></div>
  <div id="missingCostWarning" class="warning"></div>
  <div style="margin-top:1em; font-size:0.9em;">
  <strong>Legend:</strong>
  <span style="color: black; margin-left: 1em;">â–  manual Coin</span>
  <span style="color: green; margin-left: 1em;">â–  TP price</span>
  <span style="color: blue; margin-left: 1em;">â–  Subcomponent cost</span>
  <span style="color: red; margin-left: 1em;">â–  No cost found</span>
  </div>
  <script>
    let gearData = {};
    let treeRoot = null;

    async function loadGearData() {
      const res = await fetch("gearData.json");
      gearData = await res.json();
    }

    function isAlreadyDefined(itemId) {
      for (const slot in gearData) {
        if (gearData[slot].some(e => e.name === String(itemId))) return true;
      }
      return false;
    }

async function fetchTPPrice(itemId) {
  try {
    const res = await fetch(`https://api.guildwars2.com/v2/commerce/prices/${itemId}`);
    if (!res.ok) return null;
    const data = await res.json();

    return {
      buy: data.buys.unit_price ?? null,
    };
  } catch {
    return null;
  }
}

    async function computeBestSubtreeCost(node) {
  if (!node.children.length) return Number.MAX_SAFE_INTEGER;
  let sum = 0;
  for (const child of node.children) {
    const priceField = document.querySelector(`input.price-field[data-id='${child.id}']`);
    const userValRaw = priceField?.value || "";
    const userVal = Number(userValRaw.replace(',', '.').trim());

    const tpElement = document.querySelector(`input[type='checkbox'][data-id='${child.id}']`)?.parentElement.querySelector(".tp-price");
    let tpCopper = Number.MAX_SAFE_INTEGER;
    if (tpElement) {
      const tpVal = tpElement.textContent.match(/TP: (\\d+)g (\\d+)s (\\d+)c/);
      if (tpVal) {
        const [, g, s, c] = tpVal;
        tpCopper = parseInt(g)*10000 + parseInt(s)*100 + parseInt(c);
      }
    }

    let best = Number.MAX_SAFE_INTEGER;
    if (isFinite(userVal)) best = userVal;
    if (tpCopper < best) best = tpCopper;

    const count = child.count || 1;
    sum += best * count;
  }
  return sum;
}

async function buildTree(itemId, depth = 0, visited = new Set()) {
  if (depth > 10 || visited.has(itemId)) return null;
  visited.add(itemId);

  const node = { id: itemId, children: [] };

  try {
    const recipeRes = await fetch(`https://api.guildwars2.com/v2/recipes/search?output=${itemId}`);
    const recipeIds = await recipeRes.json();

    if (recipeIds.length > 0) {
      const recipe = await fetch(`https://api.guildwars2.com/v2/recipes/${recipeIds[0]}`).then(r => r.json());

      for (const ing of recipe.ingredients) {
        const child = await buildTree(ing.item_id, depth + 1, new Set(visited));
        if (child) {
          child.count = ing.count;  // ðŸ”§ Speichere Anzahl der benÃ¶tigten Einheiten
          node.children.push(child);
        }
      }
    }
  } catch (e) {
    console.warn(`Error loading recipe for item ${itemId}:`, e);
  }

  return node;
}

async function renderNode(node, container, depth = 0) {
  const wrapper = document.createElement("div");
  wrapper.className = "node";

  const isExisting = isAlreadyDefined(node.id);
  const itemData = await fetch(`https://api.guildwars2.com/v2/items/${node.id}`).then(r => r.json()).catch(() => ({}));
  const name = itemData.name || `Item ${node.id}`;
  const tpData = await fetchTPPrice(node.id);
  const hasTP = tpData && (tpData.buy !== null || tpData.sell !== null);

  const row = document.createElement("div");
  row.className = isExisting ? "existing" : "";

  const toggle = document.createElement("span");
  toggle.textContent = node.children.length ? "+" : " ";
  toggle.className = "toggle";
  toggle.addEventListener("click", () => {
    wrapper.classList.toggle("collapsed");
    toggle.textContent = wrapper.classList.contains("collapsed") ? "+" : "âˆ’";
  });

  const checkbox = document.createElement("input");
  checkbox.type = "checkbox";
  checkbox.dataset.id = node.id;
  checkbox.addEventListener("change", () => {
    document.querySelectorAll(`input[type='checkbox'][data-id='${node.id}']`).forEach(cb => {
      if (cb !== checkbox) cb.checked = checkbox.checked;
    });
  });

  const priceInput = document.createElement("input");
  priceInput.type = "number";
  priceInput.placeholder = "Coin";
  priceInput.className = "price-field";
  priceInput.dataset.id = node.id;
  priceInput.addEventListener("input", () => {
    document.querySelectorAll(`input.price-field[data-id='${node.id}']`).forEach(pi => {
      if (pi !== priceInput) pi.value = priceInput.value;
    });
    updateTotalCost();
  });

  const label = document.createElement("label");
  label.textContent = name;

  const tpSpan = document.createElement("span");
  tpSpan.className = "tp-price";

  if (tpData) {
    if (tpData.buy !== null) {
      priceInput.setAttribute("data-buy", tpData.buy);
    }
    const format = (val) => {
      const g = Math.floor(val / 10000);
      const s = Math.floor((val % 10000) / 100);
      const c = val % 100;
      return `${g}g ${s}s ${c}c`;
    };
    const buyStr = tpData.buy !== null ? `TP: Buy ${format(tpData.buy)}` : "";
    tpSpan.textContent = buyStr;
  }

  row.appendChild(toggle);
  row.appendChild(checkbox);

  if (node.count) {
    const countSpan = document.createElement("span");
    countSpan.textContent = ` Ã—${node.count}`;
    countSpan.style.marginLeft = "0.5em";
    countSpan.style.fontWeight = "bold";
    countSpan.style.color = "#666";
    label.appendChild(countSpan);
  }

  row.appendChild(label);
  row.appendChild(priceInput);
  if (hasTP) row.appendChild(tpSpan);

  wrapper.appendChild(row);
  priceInput.addEventListener("input", () => updateTotalCost());

  const childContainer = document.createElement("div");
  childContainer.className = "children";
  wrapper.appendChild(childContainer);

  container.appendChild(wrapper);

  for (const child of node.children) {
    await renderNode(child, childContainer, depth + 1);
  }

  // Subcost-Anzeige nur, wenn kein TP, aber Unterkomponenten existieren
  if (!hasTP && node.children.length > 0) {
    const sum = getBestCost(node.id, "buy", new Set());
    if (isFinite(sum)) {
      const subInfo = document.createElement("span");
      subInfo.className = "subcost-info";
      const g = Math.floor(sum / 10000);
      const s = Math.floor((sum % 10000) / 100);
      const c = sum % 100;
      subInfo.textContent = `Subcost: ${g}g ${s}s ${c}c`;
      subInfo.style.marginLeft = "0.5em";
      subInfo.style.color = "#888";
      row.appendChild(subInfo);
    }
  }

  checkbox.checked = hasTP ? false : (node.children.length === 0);
}

function getBestCost(id, type = "buy", visited = new Set()) {
  if (visited.has(id)) return Number.MAX_SAFE_INTEGER;
  visited.add(id);

  const inputs = document.querySelectorAll(`input.price-field[data-id='${id}']`);
  if (!inputs.length) return Number.MAX_SAFE_INTEGER;

  const input = inputs[0];
  const rawVal = input.value.trim();
  const uval = rawVal === "" ? Number.MAX_SAFE_INTEGER : Number(rawVal.replace(",", "."));

  const raw = input.dataset[type];
  const tpVal = raw !== undefined && raw !== "" ? Number(raw) : Number.MAX_SAFE_INTEGER;

  let best = Number.MAX_SAFE_INTEGER;
  if (isFinite(uval)) best = uval;
  if (isFinite(tpVal) && tpVal < best) best = tpVal;

  const node = input.closest(".node");
  const childFields = node?.querySelectorAll(":scope > .children > .node");

  if (childFields?.length) {
    let subSum = 0;
    for (const childNode of childFields) {
      const childInput = childNode.querySelector("input.price-field");
      const cid = childInput?.dataset.id;

      // Count robust extrahieren
      const countSpan = childNode.querySelector("label span");
      const countText = countSpan?.textContent || "";
      const match = countText.match(/Ã—\s*(\d+)/);
      const count = match ? parseInt(match[1]) : 1;

      const childCost = getBestCost(cid, type, new Set(visited));
      if (isFinite(childCost)) {
        subSum += childCost * count;
      }
    }

    // Wenn kein Preis von oben gesetzt â†’ subSum als best
    if (!isFinite(best) && isFinite(subSum)) best = subSum;
    else if (isFinite(subSum) && subSum < best) best = subSum;

    // UI-Anzeige (nur im Buy-Modus)
    if (type === "buy") {
      const subInfo = node.querySelector(".subcost-info") || document.createElement("span");
      subInfo.className = "subcost-info";
      const g = Math.floor(subSum / 10000);
      const s = Math.floor((subSum % 10000) / 100);
      const c = subSum % 100;
      subInfo.textContent = `Subcost: ${g}g ${s}s ${c}c`;
      subInfo.style.marginLeft = "0.5em";
      subInfo.style.color = "#888";
      const row = input.parentElement;
      if (!row.contains(subInfo)) row.appendChild(subInfo);
    }
  }

  return best;
}

function updateTotalCost() {
  const inputs = [...document.querySelectorAll("input.price-field")];

  function calcTotal(type) {
    let total = 0;
    let missing = [];

    for (const input of inputs) {
      const id = input.dataset.id;
      const best = getBestCost(id, type);

     if (type === "buy") {
  const label = input.parentElement.querySelector("label");
  const hasCoin = isFinite(Number(input.value));
  const hasTP = isFinite(Number(input.dataset[type]));
  const hasSub = !hasCoin && !hasTP && best < Number.MAX_SAFE_INTEGER;
  const missing = best === Number.MAX_SAFE_INTEGER;

  if (label) {
    label.style.fontWeight = "normal";
    label.style.color = hasCoin
      ? "black"
      : hasTP
      ? "green"
      : hasSub
      ? "blue"
      : "red";
  }
}
      total += best;

      const isLeaf = !input.closest(".node")?.querySelector(".children .price-field[data-id]");
      if (isLeaf && best === Number.MAX_SAFE_INTEGER) {
        missing.push(id);
      }
    }

    return { total, missing };
  }

  const buyResult = calcTotal("buy");
  const format = (val) => {
    const g = Math.floor(val / 10000);
    const s = Math.floor((val % 10000) / 100);
    const c = val % 100;
    return `${g}g ${s}s ${c}c (${val} copper)`;
  };
  document.getElementById("totalCost").innerHTML =
    `<strong>Total Cost:</strong> ${format(buyResult.total)}`;

  document.getElementById("missingCostWarning").textContent =
    buyResult.missing.length
      ? `Warning: ${buyResult.missing.length} base item(s) without TP, coin or subcomponent value.`
      : "";
}

    document.getElementById("loadBtn").addEventListener("click", async () => {
      const id = document.getElementById("itemId").value.trim();
      if (!id) return;
      await loadGearData();
      treeRoot = await buildTree(parseInt(id));
      const treeDiv = document.getElementById("tree");
      treeDiv.innerHTML = "";
      await renderNode(treeRoot, treeDiv);
      updateTotalCost();
    });

    document.getElementById("generateBtn").addEventListener("click", () => {
      const checked = [...document.querySelectorAll("input[type='checkbox']:checked")];
      const results = checked.map(box => {
        const id = box.dataset.id;
        const price = document.querySelector(`input.price-field[data-id='${id}']`).value;
        return {
          name: id,
          method: "Vendor",
          cost: [[{ currency: "Coin", amount: Math.round(Number(price || "0")) }]],
          description: "Manually entered via crafting checker"
        };
      });
      document.getElementById("output").textContent = JSON.stringify(results, null, 2);
    });
  </script>
</body>
</html>
